# 位操作符
& 与  | 或  ^ 异或  ~ 按位取反

# 不创建临时变量交换两个数
a = a^b;
b = a^b;
a = a^b;
# 相同的两数异或为0
# 0和任何数异或不变

# 整形提升：两个数运算时会转换成整形
# 整形提升是按照符号们提升，负数高们补1，正数高位补0

# 问题表达式(没有唯一的执行路径的表达式)
# 如：a*b + c*d + e*f   代码1在计算的时候，由于*比+的优先级高，只能保证，*的计算是比*早，但是优先级并不能决定第三个*比第一个+早执行
# 如：c + --c   不知道c是在--c之前或之后赋
# 如：(++a) + (++a) + (++a)   三个自加和第一个*不明确

# 走台阶，一次走一阶或者走两阶，是斐波那契

# 野指针
# 概念：指向的位置是不可知的（随机的、不正确的，没有明确限制的）
# 1. 指定未初始化 int* p; *p = 10;
# 2. 指针越界访问
# 3. 指针指向的空间释放
# int* test()
# {
#   int a = 10;
#   return &a;
# }
#
# int main()
# {
#   int* p = test();
# }
# 此时p还保存着已销毁的局部变量a的地址

# 用指针遍历数组
# 比如将数组全都赋值为1
# int* p = arr;
# for (i = 0; i< sz; i++)
# {
#   *p = 1;
#   p++;
# }
# 或者
# for (i = 0; i< sz; i++)
# {
#   *(p + 1) = 1;
# }

# 二级指针
# int** pp = &p;
# 解引用：**p

# 指针数组
# int* parr[10] = {&a, &b, &c};
# 解引用：*(parr[1])
# 指针数组模拟二维数组
# int arr[3][4] = {1,2,3,4,2,3,4,5,3,4,5,6}
# 同：int arr1[4] = {1,2,3,4}
#     int arr2[4] = {2,3,4,5}
#     int arr3[4] = {3,4,5,6}
#     int* parr[3] = {arr1, arr2, arr3}
# 都可以用 [i][j] 方式访问

# 结构体
# 声明：
# struct tag
# {
#   member-list;
# }
# 创建：
# struct Peo p1 = { 0 }

# 逗号表达式优先级最低

# 循环取数字最后一位
# 1, 先模再除
# 2. &1(按位与1)，再右移
#   统计1的个数
#   1. 循环取数字最后一位，判断最后一位是不是1
#   2. n = n&(n-1) 消除最后1个1
#   判断一个数是不是2的n次方
#   if(n & (n - 1) == 0)

# 当一个有符号和无符号比较，有符号会转换为无符号的
# int i = -1; i > sizeof(i); 为真，无符号-1大于4

# 自定义字符串拷贝，while(*dest++ = *src++)，当拷贝了'\0'，退出

# const 修饰指针变量
#   const int* p，*p不能改
#   int* const p, p不能改(但是这指向的值可以修改)

# 水仙花数
# 一个n位数，其各位数字的n次方之和刚好等于该数本身
# 如：153 = 1^3 + 5^3 + 3^3

# 指针数组和数组指针
# int* arr[10]	本质是数组
# int (*arr)[10]	本质是指针

# 点的优先组比*高
# (*p).a	结构体指针访问结构体成员
# ++的优先级比*高
# (*p)++	解引用加加
